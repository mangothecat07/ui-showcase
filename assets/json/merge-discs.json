{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0.5058823529411764, 0.9686274509803922); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0.5058823529411764, 0.9686274509803922); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.51) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 6.3426573426573425,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": ["e02c46e5-ff7e-471a-b3c7-98b82c56d157"],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "text",
      "justCreated": false,
      "isSafari": false,
      "width": 1.2419608991429643,
      "widthMode": "relative",
      "height": 281.9675726036595,
      "heightMode": "fixed",
      "left": 0.5001899518910388,
      "leftMode": "relative",
      "top": 0.49332596013030794,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fontSize": 0.19170289512680816,
      "lineHeight": 1.0214285714285714,
      "letterSpacing": -0.04347004424644175,
      "fontFamily": "Syne",
      "fontStyle": "regular",
      "fontWeight": "400",
      "textAlign": "center",
      "textContent": "K U N A L",
      "fill": ["#EDF0FF"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "fontSizeMode": "relative",
      "noTextAsHtml": false,
      "fontCSS": {
        "family": "Syne",
        "src": "https://assets.unicorn.studio/fonts/google_fonts/8vIS7w4qzmVxsWxjBZRjr0FKM_04uT6kR47NCV5Z.ttf"
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "text",
      "windowWidth": 1440
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "replicate",
      "usesPingPong": false,
      "amount": 0.505,
      "speed": 0.05,
      "texture": false,
      "parentLayer": "e02c46e5-ff7e-471a-b3c7-98b82c56d157",
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "10c7b4a3-8b75-47a1-8c09-f6b6397b931b",
            "prop": "amount",
            "transition": {
              "duration": 1000,
              "delay": 1000,
              "ease": "easeInOutExpo"
            },
            "complete": false,
            "progress": 0,
            "value": 0,
            "endValue": 0.505,
            "initialized": false,
            "breakpoints": [],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uSpacing" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uSpacing; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float rotation = (0.0000 * 2. * 3.141592653); float aspectRatio = uResolution.x/uResolution.y; vec2 aberrated = vec2(0); vec4 col = vec4(0); float repeatSpacing = uSpacing * 0.35 * mix(1., aspectRatio, 0.5); float time = (uTime * 0.025) / (repeatSpacing + 0.001);const int MAX_REPEATS = 100; for (int i = 0; i < MAX_REPEATS; ++i) { if (float(i) >= 16.0000) break; float fi = float(i); float offset = repeatSpacing * (fi - 0.5 * 16.0000 + fract(time)); aberrated = vec2(offset * sin(rotation), offset * cos(rotation)); col += texture(uTexture, uv + aberrated) * (1.0 - col.a); } fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": true,
      "aspectRatio": 1.7133956386292837,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": ["f91ec8e3-fdad-4e4d-aa97-2593f699f930"],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "image",
      "imageLoaded": false,
      "width": 1.1475883024848244,
      "widthMode": "relative",
      "height": 1.0716388221021922,
      "heightMode": "auto",
      "left": 0.46165942097463836,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fitToCanvas": 1,
      "src": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/Zz28X5RDkvcGGVYLr9X6QdTIhxy1%2Fshutterstock-122755672.webp?alt=media&token=8c8498ed-c939-4ecc-a2ae-0b1809801942",
      "naturalWidth": 1100,
      "naturalHeight": 642,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "mouse",
      "usesPingPong": true,
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 blurTrail(vec2 uv, vec2 mouseDir) { if (dot(mouseDir, mouseDir) <= 1e-8) { return texture(uTexture, uv); } vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0); float scale = 0.0001 + 0.4700 * 0.5;for (int i = 0; i <= 24; i++) { float weight = getGaussianWeight(i); vec2 offset = distorted * (1.5 + scale) * mix(1.0, float(i) / ITERATIONS, scale); vec2 st = uv - offset; vec4 samp = texture(uTexture, st); samp.rgb = chromatic_aberration(samp.rgb, st, offset * 1.5000 * 0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec4 color = vec4(0);return blurTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv; float aspectRatio = uResolution.x / uResolution.y;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.7900 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);fragColor = color; }",
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 aspectVec = vec2(aspectRatio, 1.0); vec2 uv = vTextureCoord; vec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec; float dist = length(dir); if (dist > 0.0) { dir = dir / dist; } else { dir = vec2(1.0, 0.0); }float rad = 0.3200 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 1.4000);float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0; vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec; float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.2100, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.6000 * 0.03) + 0.6000 * 0.015, 0.6000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.2300, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }",
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [
        {
          "max": null,
          "props": { "scale": 0.36 },
          "name": "Desktop",
          "min": 992
        },
        { "props": { "scale": 0.26 }, "name": "Mobile", "max": 575, "min": 0 }
      ],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sdf_shape",
      "usesPingPong": false,
      "texture": false,
      "scale": 0.36,
      "speed": 0.5,
      "trackMouseMove": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "trackMouse": 0,
      "parentLayer": "f91ec8e3-fdad-4e4d-aa97-2593f699f930",
      "animating": true,
      "isMask": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "3fff621b-4f60-4add-968b-19d46e6cbc14",
            "prop": "scale",
            "transition": {
              "duration": 1000,
              "delay": 1500,
              "ease": "easeInOutExpo"
            },
            "complete": false,
            "progress": 0,
            "value": 0,
            "endValue": 0.35,
            "initialized": false,
            "breakpoints": [],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uScale" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uScale; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float PI = 3.141592653; const float PI2 = 6.283185306; const int DISP_STEPS = 12; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }mat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, -s, s, c); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float smin(float a, float b, float k) { float h = max(k - abs(a - b), 0.0); return min(a, b) - h * h * 0.25 / k; }float sphere(vec3 p, float r) { return length(p) - r; }float sdfCylinder(vec3 p, float radius, float height) { vec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5); return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }float mergedDiscs(vec3 p) { float result = sdfCylinder(p, 0.7, 0.01 + 0.7500 * 0.5);for(float i = 1.; i < 4.; i++) { float angle = (i * 45.)/360. * 2.0 * PI; mat2 rotZMat = rot(angle); vec3 rotatedP = vec3(rotZMat * p.xy, p.z);result = smin( result, sdfCylinder(rotatedP, 0.7, 0.01 + 0.7500 * 0.5), 0.2 ); }return max(result, sphere(p, 1.4)); }vec3 getRepeat(vec3 p) { float spacing = (0.5000 + 0.0100 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.5000 + 0.0100 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scale = max(uScale, 0.000000001); float scaleFactor = 1.0/scale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0100 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.5).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.5).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.5).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return mergedDiscs(p); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float NdotV = abs(dot(eyeVector, worldNormal)); float width = fwidth(dot(eyeVector, worldNormal)); float threshold = 0.2; float edgeDampFactor = smoothstep(threshold, -threshold, width); float fresnelFactor = 1.0 - NdotV; return pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.3700 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.3700 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.1400 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) { float step = float(i) / float(DISP_STEPS); vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { vec2 e = vec2(1.0, -1.0) * eps * 0.5; return normalize( e.xyy * getMergedSDF(p + e.xyy) + e.yyx * getMergedSDF(p + e.yyx) + e.yxy * getMergedSDF(p + e.yxy) + e.xxx * getMergedSDF(p + e.xxx) ); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (0.0100 + 0.005)) * max(uScale, 0.000000001); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.0025; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float lastDistance = 0.0; float smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * smoothing); break; }lastDistance = distance;traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return vec4(0); }vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = vec3(0.0);refractionColor = sampleTexture(samplePosition, entryNormal); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5006944444444444), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000); vec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01); specularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000); finalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0); vec4 bg = texture(uTexture, vTextureCoord);if(uScale <= 0.0001 || 1.0000 <= 0.0001) { col = vec4(0); if(0 == 1) { col = bg; } fragColor = col; return; }vec2 pos = vec2(0.5, 0.5006944444444444) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0; col += dither;col = mix(vec4(0), col, 1.0000); fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "depth": false,
        "uniforms": {
          "scale": { "name": "uScale", "type": "1f", "value": 0.5 }
        },
        "isBackground": false
      },
      "id": "effect3"
    }
  ],
  "options": {
    "name": "Appear events",
    "fps": 120,
    "dpi": 2,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.33",
  "id": "9SMP9VBhIMJG7lyy2cPM"
}
