{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "wisps",
      "usesPingPong": false,
      "speed": 0.49,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) { vec2 i_st = floor(st); vec2 f_st = fract(st);float wander = 0.0000 * uTime * 0.2; float total_contribution = 0.0;for (int y = -2; y <= 2; y++) { for (int x = -2; x <= 2; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 cell_id = i_st + neighbor; vec2 point = hash(cell_id); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 starAbsPos = cell_id + point; vec2 dirToMouse = mouse_pos - starAbsPos; float distToMouse = length(dirToMouse); float attractStrength = 0.0000 * exp(-distToMouse * mix(2.0 + 0.7500 * 2., 0.5, 0.5000)) * 2.; starAbsPos += dirToMouse * attractStrength; vec2 diff = starAbsPos - st; float dist = length(diff);float contribution = radius / max(dist, radius * 0.1); float shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5; float shimmer = mix(1., (sin(shimmer_phase) + 1.), 1.0000); contribution *= shimmer; total_contribution += mix(contribution*contribution, contribution * 2., 0.2500); } }return total_contribution; }vec4 randomStyle() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0); vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.0000);uv -= vec2(0.5, 0.5); uv *= aspectRatio; uv = uv * rot(0.0000 * 2.0 * PI); uv *= 40.0 * 0.7500; uv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700); uv /= aspectRatio;mPos = mPos * rot(0.0000 * 2.0 * PI);vec2 mouseGrid = uMousePos; mouseGrid -= vec2(0.5, 0.5); mouseGrid *= aspectRatio; mouseGrid = mouseGrid * rot(0.0000 * 2.0 * PI); mouseGrid *= 40.0 * 0.7500; mouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700); mouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 0.7500) + movementOffset; vec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 0.7500) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 0.7500); vec2 st2 = uv - (mPos * 48.0 * 0.7500);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouse2 = st2 + vec2(0.0, uTime * 0.5000 * -0.05);float radius1 = 0.5 * 0.6000; float radius2 = 0.5 * 0.6000;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 0.7500); float pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 0.7500);pass1 *= 0.02; pass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1.0, bg.r, 0.2900); color.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); return color; }void main() { vec4 color;color = randomStyle(); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "vignette",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); float luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(1.0000, 1.0 - 1.0000); float halfRadius = 0.5100 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0, 0, 0), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000); vec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "vignette",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return min(src, dst); }out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); float luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.2500 * 0.5; float innerEdge = halfRadius - -1.3500 * halfRadius * 0.5; float outerEdge = halfRadius + -1.3500 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;vec3 blended = blend(6, vec3(0, 0, 0), bg.rgb); finalColor = mix(bg.rgb, blended, falloff * 0.9900);float alpha = max(bg.a, falloff * 0.9900); vec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "speed": 1,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.5000, 1. - 0.5000) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.3100 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.0000 + uTime * 0.01 + 1.0000) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1. - ringDist, 3.) * vec3(1, 1, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawRing(uv, pos, 0.5700, 0.0000); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect4"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "projection",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) { vec2 screenPos = (uv - 0.5) * 2.0; screenPos.x *= aspect; screenPos.y *= -1.0; float minFOV = radians(20.0); float maxFOV = radians(120.0); float fov = mix(minFOV, maxFOV, 0.9600); vec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0), screenPos.y * tan(fov/2.0), -1.0)); float rotX = (mousePos.y - 0.5) * PI; float rotY = (mousePos.x - 0.5) * PI * 2.0; mat3 rotateY = mat3( cos(rotY), 0.0, -sin(rotY), 0.0, 1.0, 0.0, sin(rotY), 0.0, cos(rotY) ); mat3 rotateX = mat3( 1.0, 0.0, 0.0, 0.0, cos(rotX), sin(rotX), 0.0, -sin(rotX), cos(rotX) ); return normalize(rotateX * rotateY * rayDir); }vec2 directionToUVHorizontal(vec3 dir) { float longitude = atan(dir.z, dir.x); float latitude = acos(dir.y); vec2 uv; uv.x = longitude / (2.0 * PI) + 0.5; uv.y = latitude / PI; uv.x += 0.25; return uv; }vec2 directionToUVVertical(vec3 dir) { float longitude = atan(dir.z, dir.y); float latitude = acos(dir.x); vec2 uv; uv.y = longitude / PI * -1.; uv.x = (latitude / (2.0 * PI) + 0.5) * -1.; uv.x = fract(uv.x + 0.25); return uv; }out vec4 fragColor;vec4 getRepeatHorizontalUV(vec2 uv) { vec2 finalUV = vec2(fract(uv.x), uv.y); vec4 col = texture(uTexture, finalUV); if (0.0000 > 0.0) { float blendWidth = 0.0000 * 0.1; float blendFactor = 0.0; if (finalUV.x < blendWidth) { blendFactor = 1.0 - (finalUV.x / blendWidth); } else if (finalUV.x > 1.0 - blendWidth) { blendFactor = (finalUV.x - (1.0 - blendWidth)) / blendWidth; } if (blendFactor > 0.0) { blendFactor = smoothstep(0.0, 1.0, blendFactor); vec2 oppositeUV = vec2(finalUV.x > 0.5 ? finalUV.x - 0.5 : finalUV.x + 0.5, finalUV.y); vec4 oppositeCol = texture(uTexture, oppositeUV); col = mix(col, oppositeCol, blendFactor); } } return col; }vec4 getRepeatUV(vec2 uv) { return getRepeatHorizontalUV(uv); }void main() { float aspect = 2.; vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5); vec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect); vec2 uvHorizontal = directionToUVHorizontal(rayDir); vec2 uvVertical = directionToUVVertical(rayDir); vec2 sphereUV = mix(uvHorizontal, uvVertical, 2.0100); float minFOV = radians(20.0); float maxFOV = radians(120.0); float currentFOV = mix(minFOV, maxFOV, 0.9600); float fovCompensation = tan(currentFOV/2.0); float compensatedScale = (mix(-0.1, 0.4, 0.3500) * 12.0 + 2.0) * (1.0/fovCompensation); sphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0.5, 0) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV); fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect5"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 0.5854166666666667,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0.31,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": {
        "appear": [],
        "scroll": [],
        "hover": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "hover",
            "id": "f19bd7c9-a7fb-49a3-93d4-2dc44380f6db",
            "prop": "trackMouse",
            "transition": {
              "ease": "easeInOutQuart",
              "duration": 1000,
              "delay": 0
            },
            "progress": 0,
            "rawProgress": 0,
            "lastProgress": null,
            "value": 0,
            "triggerOnElement": 1,
            "breakpoints": [],
            "uniformData": { "type": "1f", "name": "uTrackMouse" }
          }
        ]
      },
      "layerType": "text",
      "justCreated": false,
      "isSafari": false,
      "width": 0.3,
      "widthMode": "relative",
      "height": 57.599999999999994,
      "heightMode": "fixed",
      "left": 0.49999999999999994,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "y",
      "fontSize": 0.03,
      "lineHeight": 1,
      "letterSpacing": 0,
      "fontFamily": "Archivo Black",
      "fontStyle": "regular",
      "fontWeight": "400",
      "textAlign": "center",
      "textContent": "K U N A L",
      "fill": ["#777777"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "fontSizeMode": "relative",
      "noTextAsHtml": false,
      "fontCSS": {
        "family": "Archivo Black",
        "src": "https://assets.unicorn.studio/fonts/google_fonts/HTxqL289NzCGg4MzN6KJ7eW6OYuP_x7yx3A.ttf"
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg; uniform float uTrackMouse;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), uTrackMouse);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "text",
      "windowWidth": 1920
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "bulge",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; in float zPos;uniform sampler2D uTexture;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);float intensity = 0.0000 * 0.5;float rad = (0.5000 - 0.25) * -2. * 3.14159; vec2 rotatedLightPosition = vec2(cos(rad), sin(rad)); vec3 lightPosition = vec3(vec2(0.5) * rotatedLightPosition * 2., 1.0);float diff = max(dot(normalize(vVertexPosition), lightPosition), 0.0); color.rgb += (diff * intensity - intensity);float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord; out vec3 vVertexPosition; out float zPos;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }float bezier(float t) { return ease(3, t); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 bulge(vec3 pos) { vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec2 mousePosAdjusted = mix((vec2(0.5, 0.5) - 0.5) * 2., (uMousePos - 0.5) * 2., 0.0000); vec2 skew = vec2(0.5000, 1. - 0.5000); mat2 rotation = rot(0.0000 * 2. * 3.14159);float dist = distance(pos.xy * aspectRatio * rotation * skew, mousePosAdjusted * aspectRatio * rotation * skew);float t = max(0., 1. - dist/0.2900); float bulge = bezier(t) * (1.6400 - 0.5);float luma = dot(texture(uTexture, (pos.xy + 1.) * 0.5).rgb, vec3(0.299, 0.587, 0.114));bulge += luma * bezier(t) * 0.0000; bulge = min(1., bulge);pos.xy += bulge * pos.xy; pos.z -= bulge; return pos; }void main() { vec3 pos = bulge(aVertexPosition); vec3 pos_dx = bulge(aVertexPosition + vec3(0.01, 0.0, 0.0)); vec3 pos_dy = bulge(aVertexPosition + vec3(0.0, 0.01, 0.0)); vec3 dx = pos_dx - pos; vec3 dy = pos_dy - pos; vec3 normal = normalize(cross(dx, dy));vVertexPosition = normal;zPos = pos.z;gl_Position = vec4(pos, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "depth": true,
        "uniforms": {},
        "isBackground": false,
        "heightSegments": 500,
        "widthSegments": 500
      },
      "id": "effect6"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "bloom",
      "usesPingPong": false,
      "texture": false,
      "animating": false,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.5000 - 0.1, 0.5000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.5000 - 0.1, 0.5000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.5000 - 0.1, 0.5000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.3300; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 finalPass(vec4 bloomColor) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(1, 1, 1); bloomColor.rgb += dither; bloomColor.a = luma(bloomColor); vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.3800 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "pass", "value": 1, "downSample": 0.25 },
          { "prop": "pass", "value": 2, "downSample": 0.25, "includeBg": true },
          { "prop": "pass", "value": 3, "downSample": 0.25 },
          { "prop": "pass", "value": 4, "downSample": 0.25, "includeBg": true },
          { "prop": "pass", "value": 5, "downSample": 0.5 },
          { "prop": "pass", "value": 6, "downSample": 0.5, "includeBg": true },
          { "prop": "pass", "value": 7, "downSample": 1, "includeBg": true }
        ]
      },
      "id": "effect7"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "chromab",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }out vec4 fragColor; const float PI = 3.1415926;vec3 getAbberatedColor(vec3 color, vec3 left, vec3 center, vec3 right) { return vec3(left.r, mix(color.g, center.g, float(1)), right.b); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 mPos = vec2(0.4850702760068112, 0.5000000000000001) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = vec2(0.4850702760068112, 0.5000000000000001); float angle = ((0.0135 + uTime * 0.05) * 360.0) * PI / 180.0; vec2 rotation = vec2(sin(angle), cos(angle)); vec4 color = texture(uTexture, uv);float mDist = ease(0, max(0., 1. - distance(uv * vec2(aspectRatio, 1.), mPos * vec2(aspectRatio, 1.)) * 4. * (1. - 1.0000)));vec2 aberrated;aberrated = 0.5700 * rotation * 0.03 * mix(1.0, distance(uv, pos) * (1.0 + 1.0000), 1.0000); aberrated *= mDist;float amt = length(aberrated);if(amt < 0.001) { fragColor = color;return; }vec4 left = vec4(0); vec4 right = vec4(0); vec4 center = vec4(0);float steps = max(2., min(float(16), 24.)); float invSteps = 1.0 / (steps + 1.0);for (float i = 0.0; i <= steps; i++) { vec2 offset = aberrated * (i * invSteps); left += texture(uTexture, uv - offset) * invSteps; right += texture(uTexture, uv + offset) * invSteps; } for (float i = 0.0; i <= steps; i++) { vec2 offset = aberrated * ((i / steps) - 0.5); center += texture(uTexture, uv + offset) * invSteps; } color.rgb = getAbberatedColor(color.rgb, left.rgb, center.rgb, right.rgb);color.a = max(max(left.a, center.a), right.a); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect8"
    }
  ],
  "options": {
    "name": "black hole (Remix)",
    "fps": 120,
    "dpi": 1,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.33",
  "id": "ONopEvmqUIClUr5NG8gn"
}
