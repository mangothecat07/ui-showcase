{
    "history": [
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "gradient",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0,
            "mouseMomentum": 0,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
            ],
            "data": {
                "downSample": 0.5,
                "depth": false,
                "uniforms": {},
                "isBackground": true
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "locked": false,
            "aspectRatio": 1,
            "layerName": "",
            "userDownsample": 1,
            "isElement": true,
            "opacity": 1,
            "effects": [
                "351478ee-1db3-4121-ab41-a299fc97b757",
                "0749721b-8dc4-4afe-9a61-65b076d5cfd5"
            ],
            "displace": 0,
            "trackMouse": 0,
            "anchorPoint": "center",
            "mouseMomentum": 0,
            "blendMode": "NORMAL",
            "bgDisplace": 0,
            "mask": 0,
            "maskBackground": {
                "type": "Vec3",
                "_x": 0,
                "_y": 0,
                "_z": 0
            },
            "maskAlpha": 0,
            "maskDepth": 0,
            "dispersion": 0,
            "axisTilt": 0,
            "states": {
                "appear": [],
                "scroll": [],
                "hover": []
            },
            "layerType": "image",
            "imageLoaded": false,
            "width": 0.7394254526319742,
            "widthMode": "relative",
            "height": 0.9859006035092989,
            "heightMode": "auto",
            "left": 0.5,
            "leftMode": "relative",
            "top": 0.4444609326689762,
            "topMode": "relative",
            "rotation": 0,
            "fitToCanvas": 0,
            "src": "./moltengold.jpg",
            "naturalWidth": 260,
            "naturalHeight": 260,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "uniforms": {}
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "swirl",
            "usesPingPong": false,
            "speed": 0.06,
            "trackMouse": 0.02,
            "mouseMomentum": 0.82,
            "parentLayer": "351478ee-1db3-4121-ab41-a299fc97b757",
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float angle = 0.6300 * 10.; vec2 originalUV = uv; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0200);uv -= pos; vec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y); float distanceToCenter = length(R); distanceToCenter += 0.0000*0.5; if (distanceToCenter <= 1.4540) { float rot = atan(R.y, R.x) + angle * smoothstep(1.4540, 0., distanceToCenter); uv = vec2(cos(rot + uTime / 20. + 0.0139 * 6.28), sin(rot + uTime / 20. + 0.0139 * 6.28)); uv = distanceToCenter * uv + pos; } float t = smoothstep(0., 1.4540, distanceToCenter); vec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, 1.0000)); fragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "locked": false,
            "aspectRatio": 5.076923076923077,
            "layerName": "",
            "userDownsample": 1,
            "isElement": true,
            "opacity": 1,
            "effects": [],
            "displace": 0,
            "trackMouse": 0,
            "anchorPoint": "center",
            "mouseMomentum": 0,
            "blendMode": "NORMAL",
            "bgDisplace": 0,
            "mask": 0,
            "maskBackground": {
                "type": "Vec3",
                "_x": 0,
                "_y": 0,
                "_z": 0
            },
            "maskAlpha": 0,
            "maskDepth": 0,
            "dispersion": 0,
            "axisTilt": 0,
            "states": {
                "appear": [],
                "scroll": [],
                "hover": []
            },
            "layerType": "text",
            "justCreated": false,
            "isSafari": false,
            "width": 0.3614968879534096,
            "widthMode": "relative",
            "height": 113.92629196107457,
            "heightMode": "fixed",
            "left": 0.5002532691880517,
            "leftMode": "relative",
            "top": 0.78,
            "topMode": "relative",
            "rotation": 0,
            "fontSize": 0.06937819061732105,
            "lineHeight": 1.0263157894736843,
            "letterSpacing": 0,
            "fontFamily": "Unbounded",
            "fontStyle": "regular",
            "fontWeight": "400",
            "textAlign": "center",
            "textContent": "Kunal",
            "fill": [
                "#FF894D"
            ],
            "gradientAngle": 0,
            "gradientType": "linear",
            "fontSizeMode": "relative",
            "fontCSS": {
                "family": "Unbounded",
                "src": "https://assets.unicorn.studio/fonts/studio_picks/Unbounded%2FUnbounded-Regular.ttf"
            },
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "uniforms": {}
            },
            "windowWidth": 1600
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "bloom",
            "usesPingPong": false,
            "animating": false,
            "mouseMomentum": 0,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.7100 - 0.1, 0.7100, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.7100 - 0.1, 0.7100, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.7100 - 0.1, 0.7100, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.5000, 1. - 0.5000); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.7700; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
                "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 finalPass(vec4 bloomColor) { float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(1, 0.7019607843137254, 0.2549019607843137); bloomColor.rgb += dither; bloomColor.a = luma(bloomColor); vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.3300 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "downSample": 0.5,
                "depth": false,
                "uniforms": {},
                "isBackground": false,
                "passes": [
                    {
                        "prop": "pass",
                        "value": 1,
                        "downSample": 0.25
                    },
                    {
                        "prop": "pass",
                        "value": 2,
                        "downSample": 0.25,
                        "includeBg": true
                    },
                    {
                        "prop": "pass",
                        "value": 3,
                        "downSample": 0.25
                    },
                    {
                        "prop": "pass",
                        "value": 4,
                        "downSample": 0.25,
                        "includeBg": true
                    },
                    {
                        "prop": "pass",
                        "value": 5,
                        "downSample": 0.5
                    },
                    {
                        "prop": "pass",
                        "value": 6,
                        "downSample": 0.5,
                        "includeBg": true
                    },
                    {
                        "prop": "pass",
                        "value": 7,
                        "downSample": 1,
                        "includeBg": true
                    }
                ]
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "stars",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0.19,
            "mouseMomentum": 0.81,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b; }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return fract(sin(p) * 18.5453); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec3 hue(float h, float angle) { const float PI = 3.14159265358979323846; return vec3(0.5) + 0.5 * cos(h + 2.0 * PI * angle + vec3(0, 2, 4)); }void main() { vec2 scaleRatio = vec2(1080) * vec2(uResolution.x/uResolution.y, 1); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.1900); vec2 uv = (vTextureCoord - pos) * scaleRatio * 0.2500 * 0.01 * rot(0.0000 * PI * 2.); float time = floor(uTime * 0.5) * 2.;vec2 i_uv = floor(uv); vec2 f_uv = fract(uv); vec2 point = vec2(0);vec3 d = vec3(1e10); vec2 closestPoint;for (int y = -1; y <= 1; y++) { for (int x = -1; x <= 1; x++) { vec2 tile_offset = vec2(float(x), float(y)); vec2 o = hash(i_uv + tile_offset + vec2(time * 0.05)); tile_offset += o - f_uv;float dist = dot(tile_offset, tile_offset); if (dist < d.x) { d.y = d.x; d.x = dist; closestPoint = tile_offset; point = o; } else if (dist < d.y) { d.y = dist; } } }d = sqrt(d); float r = sqrt(d.x); vec2 toCenter = closestPoint; vec2 toCenterRot45 = toCenter * rot(-PI/4.);vec2 closestPointOriginal = closestPoint * rot(-abs(0.0000) * PI * 2.) / (0.2500 * 0.01) / scaleRatio + vTextureCoord; vec4 closestPointCol = texture(uTexture, closestPointOriginal); float closestPointR = luma(closestPointCol); float mixThresh = mix(1., closestPointR, 1.0000); float stepThresh = step(1.0000, closestPointR); closestPointR = mixThresh;float crossShape; float crossShape2;if(2 > 0) { crossShape = min(abs(toCenter.x), abs(toCenter.y)); crossShape2 = min(abs(toCenterRot45.x), abs(toCenterRot45.y)); } else { crossShape = abs(toCenter.x), abs(toCenter.y); crossShape2 = abs(toCenterRot45.x), abs(toCenterRot45.y); } float proximityFactor = sqrt(d.y) - sqrt(d.x); float radialGradient = (1.0 - length(toCenter)) * closestPointR * (0.7300*1.5); crossShape = 1.0 - smoothstep(-0.04, 0.04 * (proximityFactor - smoothstep(1., -0.5, 0.7100)) * closestPointR * closestPointR, crossShape); if(2 == 2) { crossShape += 1.0 - smoothstep(-0.04, 0.04 * (proximityFactor - smoothstep(1., -0.5, 0.7100)) * closestPointR * closestPointR, crossShape2); }vec3 cross = mix(vec3(crossShape), vec3(crossShape) * hue(closestPointR, proximityFactor*5.), 0.3900); vec3 bloom = vec3(smoothstep(0., 4., radialGradient * proximityFactor));vec4 color = texture(uTexture, vTextureCoord); vec3 rgb = mix(vec3(1, 0.8196078431372549, 0.596078431372549), mix(vec3(1, 0.8196078431372549, 0.596078431372549), closestPointCol.rgb, 0.5), 1.0000); color.rgb += rgb * (cross + bloom) * 10.; fragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "sdf_shape",
            "usesPingPong": false,
            "texture": {
                "svgSrc": "https://www.svgrepo.com/download/396902/letter-k.svg",
                "sampler": "uCustomTexture",
                "thumb": "https://www.svgrepo.com/download/396902/letter-k.svg",
                "name": "legend.svg",
                "src": "./image.png"
            },
            "speed": 0.5,
            "trackMouseMove": 0,
            "mouseMomentum": 1,
            "trackMouse": 0.31,
            "parentLayer": "0749721b-8dc4-4afe-9a61-65b076d5cfd5",
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uCustomTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float opExtrusion(vec3 p, float d, float h) { vec2 w = vec2( d, abs(p.z) - h ); return min(max(w.x,w.y),0.0) + length(max(w,0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }float median(float r, float g, float b) { return max(min(r, g), min(max(r, g), b)); }float sdCustom(vec3 p) { p *= rotX(radians(90.0)); p *= rotY(radians(180.0)); p *= rotZ(radians(180.0)); vec2 uv = p.xy * 0.25 + 0.5; if (customTexAspect > 1.0) { uv.y = (uv.y - 0.5) * customTexAspect + 0.5; } else { uv.x = (uv.x - 0.5) / customTexAspect + 0.5; }vec4 sdColor = texture(uCustomTexture, uv); float msdf = median(sdColor.r, sdColor.g, sdColor.b); float sdf = sdColor.a; float sd = msdf; if(sdf < 1.) { float tuning = 0.023; sd = mix(msdf, max(msdf - tuning, sdf), sdf); }float screenPxDistance = sd - 0.5; float d = -screenPxDistance;return opExtrusion(p, d, 0.2500 * 0.5); }vec3 getRepeat(vec3 p) { float spacing = (0.5000 + 0.0500 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.5000 + 0.0500 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scale = max(0.2480, 0.000000001); float scaleFactor = 1.0/scale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0500 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.3100); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.4995).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.4995).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.4995).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sdCustom(p); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float NdotV = abs(dot(eyeVector, worldNormal)); float width = fwidth(dot(eyeVector, worldNormal)); float threshold = 0.2; float edgeDampFactor = smoothstep(threshold, -threshold, width); float fresnelFactor = 1.0 - NdotV; return pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.5000 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { vec2 e = vec2(eps, 0.0); vec3 normal = normalize(vec3( getMergedSDF(p + e.xyy) - getMergedSDF(p - e.xyy), getMergedSDF(p + e.yxy) - getMergedSDF(p - e.yxy), getMergedSDF(p + e.yyx) - getMergedSDF(p - e.yyx) )); return normal; }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (0.0500 + 0.005)) * max(0.2480, 0.000000001); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.0025; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float lastDistance = 0.0; float smoothing = mix(1., 4., 0.3500);for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * smoothing); break; }lastDistance = distance;traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return vec4(0); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.0000); vec3 refractionColor = sampleTexture(samplePosition, entryNormal); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.48629981708244957, 0.5510585305105853), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 1.0000 + 0.01); vec3 specularEffect = specFactor * 1.0000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000); finalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0);customTexSize = textureSize(uCustomTexture, 0); customTexAspect = float(customTexSize.x) / float(customTexSize.y);if(float(customTexSize.x) == float(uResolution.x) && float(customTexSize.y) == float(uResolution.y)) { discard; }if(0.2480 <= 0.0001) { col = vec4(0); if(0 == 1) { col = texture(uTexture, vTextureCoord); } fragColor = col; return; }vec2 pos = vec2(0.48629981708244957, 0.5510585305105853) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            }
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "fxaa",
            "usesPingPong": false,
            "animating": false,
            "mouseMomentum": 0,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;const float FXAA_REDUCE_MIN = 0.0078125; const float FXAA_REDUCE_MUL = 0.125; const float FXAA_SPAN_MAX = 8.0;out vec4 fragColor;void main() { vec2 res = 1.0 / uResolution;vec3 rgbNW = texture(uTexture, (vTextureCoord.xy + vec2(-1.0, -1.0) * res)).xyz; vec3 rgbNE = texture(uTexture, (vTextureCoord.xy + vec2(1.0, -1.0) * res)).xyz; vec3 rgbSW = texture(uTexture, (vTextureCoord.xy + vec2(-1.0, 1.0) * res)).xyz; vec3 rgbSE = texture(uTexture, (vTextureCoord.xy + vec2(1.0, 1.0) * res)).xyz; vec4 rgbaM = texture(uTexture, vTextureCoord.xy * res); vec3 rgbM = rgbaM.xyz; vec3 luma = vec3(0.299, 0.587, 0.114);float lumaNW = dot(rgbNW, luma); float lumaNE = dot(rgbNE, luma); float lumaSW = dot(rgbSW, luma); float lumaSE = dot(rgbSE, luma); float lumaM = dot(rgbM, luma); float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE))); float lumaMax = max(lumaM, max(max(lumaNW, lumaNE) , max(lumaSW, lumaSE)));vec2 dir; dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE)); dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce); dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * res; vec4 rgbA = (1.0/2.0) * ( texture(uTexture, vTextureCoord.xy + dir * (1.0/3.0 - 0.5)) + texture(uTexture, vTextureCoord.xy + dir * (2.0/3.0 - 0.5))); vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * ( texture(uTexture, vTextureCoord.xy + dir * (0.0/3.0 - 0.5)) + texture(uTexture, vTextureCoord.xy + dir * (3.0/3.0 - 0.5))); float lumaB = dot(rgbB, vec4(luma, 0.0));if ((lumaB < lumaMin) || (lumaB > lumaMax)) { fragColor = rgbA; } else { fragColor = rgbB; } }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            }
        }
    ],
    "options": {
        "name": "Pro Modal",
        "fps": 60,
        "dpi": 2,
        "scale": 1,
        "isProduction": 1,
        "freePlan": false
    },
    "version": "1.4.21",
    "id": "0psqsaNRhSle0eUdze5I"
}