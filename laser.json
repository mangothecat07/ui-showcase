{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 0.25,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "radius": 0.2,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "66851a5d-e0a1-4fb8-85a0-e4f6e64e4c42",
            "prop": "radius",
            "transition": {
              "delay": 1000,
              "duration": 1000,
              "ease": "easeInOutQuart"
            },
            "complete": false,
            "progress": 0,
            "value": 0,
            "endValue": 0.2,
            "initialized": false,
            "breakpoints": [],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uRadius" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uRadius;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.3400, 1. - 0.3400) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; brightness = mix(brightness, brightness*brightness, 1.0000); return brightness * vec3(0.3176470588235294, 0.3137254901960784, 0.9686274509803922); }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, -0.009756097560975618) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "radius": 0.1,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "2f8564a6-fd26-4502-922f-39f0a937d72f",
            "prop": "radius",
            "transition": {
              "delay": 1000,
              "ease": "easeInOutQuart",
              "duration": 1000
            },
            "complete": false,
            "progress": 0,
            "value": 0,
            "endValue": 0.1,
            "initialized": false,
            "breakpoints": [],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uRadius" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uRadius;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(1.0000, 1. - 1.0000) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; brightness = mix(brightness, brightness*brightness, 0.0100); return brightness * vec3(0.3176470588235294, 0.3137254901960784, 0.9686274509803922); }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5041811846689895) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": -0.3 },
      "radius": 0.23,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "1cb85c30-e701-40fe-83ad-34562d8ec870",
            "prop": "pos",
            "transition": {
              "duration": 2000,
              "delay": 1000,
              "ease": "easeOutCirc"
            },
            "complete": false,
            "progress": 0,
            "value": { "type": "Vec2", "_x": 0.5, "_y": -0.35 },
            "endValue": { "type": "Vec2", "_x": 0.5, "_y": 1.3 },
            "initialized": false,
            "breakpoints": [],
            "loop": "forwards",
            "loopDelay": 3000,
            "uniformData": { "type": "2f", "name": "uPos" }
          },
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "5fb55e3e-3586-4397-a17f-e766933f7c89",
            "prop": "radius",
            "transition": {
              "ease": "easeInOutQuart",
              "duration": 40,
              "delay": 0
            },
            "complete": false,
            "progress": 0,
            "value": 0.16,
            "endValue": 0.24,
            "initialized": false,
            "breakpoints": [],
            "loop": "reverse",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uRadius" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uPos; uniform float uRadius;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.3300, 1. - 0.3300) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; brightness = mix(brightness, brightness*brightness, 1.0000); return brightness * vec3(0.3176470588235294, 0.3137254901960784, 0.9686274509803922); }vec3 getBeam(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.6017797552836486,
      "layerName": "Texture Image",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [
        "a7ba54de-573d-41fb-9026-e1389c63c85c",
        "468998e2-89a2-4a1c-90bc-465c4b2a7c3b"
      ],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "COLOR_DODGE",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "image",
      "imageLoaded": false,
      "width": 0.7921115451388889,
      "widthMode": "relative",
      "height": 1.0930381944444445,
      "heightMode": "relative",
      "left": 0.5,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fitToCanvas": 0,
      "src": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/Zz28X5RDkvcGGVYLr9X6QdTIhxy1%2FUntitled%20design%20-%202025-10-14T141250.707.webp?alt=media&token=bfcd11a8-6529-41a6-a592-d78147e93840",
      "naturalWidth": 1440,
      "naturalHeight": 899,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (8 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(8, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "projection",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "parentLayer": "468998e2-89a2-4a1c-90bc-465c4b2a7c3b",
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) { vec2 screenPos = (uv - 0.5) * 2.0; screenPos.x *= aspect; screenPos.y *= -1.0; float minFOV = radians(20.0); float maxFOV = radians(120.0); float fov = mix(minFOV, maxFOV, 0.0000); vec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0), screenPos.y * tan(fov/2.0), -1.0)); float rotX = (mousePos.y - 0.5) * PI; float rotY = (mousePos.x - 0.5) * PI * 2.0; mat3 rotateY = mat3( cos(rotY), 0.0, -sin(rotY), 0.0, 1.0, 0.0, sin(rotY), 0.0, cos(rotY) ); mat3 rotateX = mat3( 1.0, 0.0, 0.0, 0.0, cos(rotX), sin(rotX), 0.0, -sin(rotX), cos(rotX) ); return normalize(rotateX * rotateY * rayDir); }vec2 directionToUVHorizontal(vec3 dir) { float longitude = atan(dir.z, dir.x); float latitude = acos(dir.y); vec2 uv; uv.x = longitude / (2.0 * PI) + 0.5; uv.y = latitude / PI; uv.x += 0.25; return uv; }vec2 directionToUVVertical(vec3 dir) { float longitude = atan(dir.z, dir.y); float latitude = acos(dir.x); vec2 uv; uv.y = longitude / PI * -1.; uv.x = (latitude / (2.0 * PI) + 0.5) * -1.; uv.x = fract(uv.x + 0.25); return uv; }out vec4 fragColor;vec4 getRepeatVerticalUV(vec2 uv) { vec2 finalUV = vec2(uv.x, fract(uv.y)); vec4 col = texture(uTexture, finalUV); if (0.6400 > 0.0) { float blendWidth = 0.6400 * 0.1; float blendFactor = 0.0; if (finalUV.y < blendWidth) { blendFactor = 1.0 - (finalUV.y / blendWidth); } else if (finalUV.y > 1.0 - blendWidth) { blendFactor = (finalUV.y - (1.0 - blendWidth)) / blendWidth; } if (blendFactor > 0.0) { blendFactor = smoothstep(0.0, 1.0, blendFactor); vec2 oppositeUV = vec2(finalUV.x, finalUV.y > 0.5 ? finalUV.y - 0.5 : finalUV.y + 0.5); vec4 oppositeCol = texture(uTexture, oppositeUV); col = mix(col, oppositeCol, blendFactor); } } return col; }vec4 getRepeatUV(vec2 uv) { return getRepeatVerticalUV(uv); }void main() { float aspect = 2.; vec2 mPos = vec2(0.5, 0.5055749128919861) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5); vec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect); vec2 uvHorizontal = directionToUVHorizontal(rayDir); vec2 uvVertical = directionToUVVertical(rayDir); vec2 sphereUV = mix(uvHorizontal, uvVertical, 0.0000); float minFOV = radians(20.0); float maxFOV = radians(120.0); float currentFOV = mix(minFOV, maxFOV, 0.0000); float fovCompensation = tan(currentFOV/2.0); float compensatedScale = (mix(-0.1, 0.4, 0.2100) * 12.0 + 2.0) * (1.0/fovCompensation); sphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0, 0.4) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV); fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect4"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "noiseFill",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "parentLayer": "a7ba54de-573d-41fb-9026-e1389c63c85c",
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }vec3 blend (int blendMode, vec3 src, vec3 dst) { return (src + dst) - 1.0; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.14159265359; const float TAU = 6.28318530718;vec3 anchoredPal(float t, vec3 col1, vec3 col2) { vec3 mid = 0.5 * (col1 + col2); vec3 axisAmp = 0.5 * (col2 - col1);vec3 base = mid + axisAmp * cos(TAU * t);vec3 axis = length(axisAmp) > 0.0001 ? normalize(axisAmp) : vec3(1.0, 0.0, 0.0); vec3 ref = abs(axis.x) > 0.9 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); vec3 tangent1 = normalize(cross(axis, ref)); vec3 tangent2 = normalize(cross(axis, tangent1));float richness = 0.24 * length(axisAmp) + 0.02; vec3 ripple = tangent1 * sin(TAU * (t * 2.0 + 0.123)) + tangent2 * sin(TAU * (t * 3.0 + 0.437));vec3 col = base + (richness * 0.5000) * ripple; col = 1./(1. + exp(-col * 4. + 0.25) * 7.5); return col; }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getPerlinNoise(vec2 uv) { float turb = 0.6700 * 3.2; vec2 skew = vec2(0.9600, 1. - 0.9600); vec2 drift = vec2(0, -0.1300 * uTime * 0.0125) * mix(1., 14., 15.0000); float noise = perlin_noise(vec3( uv * skew - drift, 0.0000 + uTime * 0.03 ));return mix(0.5, noise * 0.5 + 0.5, turb); }float getNoise(vec2 uv) { return getPerlinNoise(uv); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1.0);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, 0.0000); float scale = mix(1., 14., 15.0000); vec2 drift = vec2(0, -0.1300 * uTime * 0.0125); mat2 rotation = rot(0.0000 * 2. * PI);vec2 st = (uv - pos) * aspect * scale * rotation; float noise = getNoise(st);if (0.0000 > 0.0) { vec2 toMouse = (uv - uMousePos) * aspect; float r = length(toMouse); float radius = mix(0.1, 1., 0.5000); float falloff = 1.0 - smoothstep(0.0, radius, r); vec2 dir = toMouse / max(r, 1e-5); vec2 uvBulgeOffsetAspect = -dir * (0.0000 * radius) * falloff * falloff; vec2 offset = uvBulgeOffsetAspect / aspect * r * 5.;st = (uv - pos + offset * noise) * aspect * scale * rotation; noise = getNoise(st); }vec4 color = texture(uTexture, uv); vec4 bg = color; float shift = 0.0000 + (0.0000 * uTime * 0.01); vec3 noiseColor = anchoredPal(noise + shift, vec3(1, 1, 1), vec3(0, 0, 0)); color.rgb = noiseColor.rgb;float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither * 0.5;color.rgb = blend(10, bg.rgb, color.rgb);color.rgb = mix(bg.rgb, color.rgb, 1.0000); color.a = max(bg.a, 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect5"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "stretch",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0)); }out vec4 fragColor;vec2 rotate(vec2 v, float angle) { float c = cos(angle); float s = sin(angle); return vec2(v.x * c - v.y * s, v.x * s + v.y * c); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }void main() { vec2 uv = vTextureCoord; float angle = (0.5000 - 0.25) * -6.28318530718; float stretchX = vec2(0, 1).x * 4. * 1.0000; float stretchY = vec2(0, 1).y * 4. * 1.0000;vec2 pos = vec2(0.5008710801393729, 1.0473383662408053) + (uMousePos - 0.5) * 0.0000; vec2 offset = uv - pos; vec2 rotatedOffset = rotate(offset, -angle); vec2 stretchedOffset = rotatedOffset; if (1 == 1) { if (rotatedOffset.x > 0.0) { float stretchIntensity = rotatedOffset.x; float easedIntensity = ease(16, stretchIntensity); stretchedOffset.x = rotatedOffset.x / (1.0 + stretchX * easedIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity); } } else if (1 == 2) { float stretchIntensity = abs(rotatedOffset.x); float easedIntensity = ease(16, stretchIntensity); stretchedOffset.x = sign(rotatedOffset.x) * stretchIntensity / (1.0 + stretchX * easedIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity); } vec2 finalOffset = rotate(stretchedOffset, angle); vec2 st = pos + finalOffset; vec4 color = texture(uTexture, st);color.rgb = chromatic_aberration(color.rgb, st, length(st - uv) * 0.05 * 0.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect6"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "fog",
      "usesPingPong": false,
      "speed": 0.5,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.7400 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.5500 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6220 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0108 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.6600, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 0)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.7400 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.5500 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6220 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0108 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.6600, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(0, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.7400 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.5500 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6220 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0108 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.6600, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.7400 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.5500 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6220 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0108 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.6600, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, -1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.7400 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 0.5500 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.6220 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0108 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 fogComposite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 blur = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; float fogNoise = fnoise(uv); float fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.6600 * (0.3900 * 2.5)); blur.rgb = Tonemap_ACES(blur.rgb * (1.0000 + 0.5)) + grain * 0.05; vec4 foggedBlur = vec4(blur.rgb * vec3(1, 1, 1), blur.a); foggedBlur.rgb += (0.0000 * 0.25 * fogMask * vec3(1, 1, 1)); foggedBlur.rgb = blend(4, bg.rgb, foggedBlur.rgb * fogMask); return foggedBlur; }vec4 getColor(vec2 uv) { return fogComposite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "downSample": 0.25,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "pass", "value": 1, "downSample": 0.25 },
          { "prop": "pass", "value": 2, "downSample": 0.25 },
          { "prop": "pass", "value": 3, "downSample": 0.25 },
          { "prop": "pass", "value": 4, "includeBg": true }
        ]
      },
      "id": "effect7"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 4.864883325718256,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 0,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "c6f7f616-f881-48ce-ae05-c17c9b3320e3",
            "prop": "opacity",
            "transition": {
              "delay": 1225,
              "ease": "easeInOutElastic",
              "duration": 1000
            },
            "complete": false,
            "progress": 0,
            "value": 0,
            "endValue": 1,
            "initialized": false,
            "breakpoints": [],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uOpacity" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "layerType": "text",
      "justCreated": false,
      "isSafari": false,
      "width": 0.5,
      "widthMode": "relative",
      "height": 158.9966188728277,
      "heightMode": "fixed",
      "left": 0.5154513888888889,
      "leftMode": "relative",
      "top": 0.9101524522569445,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fontSize": 0.052000000000000005,
      "lineHeight": 2.1233522819554977,
      "letterSpacing": 0,
      "fontFamily": "Material Symbols",
      "fontStyle": "regular",
      "fontWeight": "400",
      "textAlign": "left",
      "textContent": "K U N A L",
      "fill": [
        "#7D8DFD",
        "#7D8DFD",
        "#7D8DFD",
        "#7D8DFD",
        "#EDF0FF",
        "#EDF0FF",
        "#7D8DFD",
        "#7D8DFD",
        "#7D8DFD",
        "#7D8DFD"
      ],
      "gradientAngle": 0.31666666666666665,
      "gradientType": "linear",
      "fontSizeMode": "relative",
      "noTextAsHtml": true,
      "fontCSS": {
        "family": "Material Symbols",
        "src": "https://assets.unicorn.studio/fonts/google_fonts/d6kSkb-sS9m3-i1LgQNcsFOOuLQXvG559b5GLMxCWRtThFK5gn7xw7XblIl2peTfMb7ONaa2_wzcUHR1Ukiw2RYw2vadH3BFk0G4701x-cU0BaNVXEDuRbn3PT2vOA.ttf"
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform float uOpacity; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "text",
      "windowWidth": 1440
    }  ],
  "options": {
    "name": "Huly Laser",
    "fps": 120,
    "dpi": 2,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.33",
  "id": "lvcwN9EzqYQUgIzeauG1"
}
